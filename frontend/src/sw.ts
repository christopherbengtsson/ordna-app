/// <reference lib="webworker" />
import { precacheAndRoute, cleanupOutdatedCaches } from 'workbox-precaching';
import { clientsClaim } from 'workbox-core';
import { initializeApp } from 'firebase/app';
import { getMessaging, onBackgroundMessage } from 'firebase/messaging/sw';
import type { NotificationData } from '@/common/model/notification/NotificationData';
import type { MessagePayload } from 'firebase/messaging';
import { getNotificationText } from './locales/i18n-sw';

declare let self: ServiceWorkerGlobalScope;

// Take control of all pages immediately
self.skipWaiting();
clientsClaim();

// Clean up old caches
cleanupOutdatedCaches();

// Precache all assets generated by Vite
// eslint-disable-next-line @typescript-eslint/no-explicit-any
precacheAndRoute((self as any).__WB_MANIFEST);

// Firebase configuration
const firebaseConfig = {
  apiKey: import.meta.env.VITE_FIREBASE_API_KEY,
  authDomain: import.meta.env.VITE_FIREBASE_AUTH_DOMAIN,
  projectId: import.meta.env.VITE_FIREBASE_PROJECT_ID,
  storageBucket: import.meta.env.VITE_FIREBASE_STORAGE_BUCKET,
  messagingSenderId: import.meta.env.VITE_FIREBASE_MESSAGING_SENDER_ID,
  appId: import.meta.env.VITE_FIREBASE_APP_ID,
};

// Initialize Firebase in service worker
const app = initializeApp(firebaseConfig);
const messaging = getMessaging(app);

// Handle background messages
onBackgroundMessage(messaging, (payload: MessagePayload) => {
  console.log('[sw.ts] Received background message:', payload);

  // Generate localized notification text from payload data
  const notificationData = (payload.data ?? {}) as NotificationData;
  const { title, body } = getNotificationText(notificationData);

  const notificationOptions: NotificationOptions = {
    body,
    icon: '/pwa-192x192.png',
    badge: '/pwa-64x64.png',
    data: notificationData,
    tag: notificationData.game_id ?? 'default',
    requireInteraction: false,
  };

  self.registration.showNotification(title, notificationOptions);
});

// Handle notification clicks
self.addEventListener('notificationclick', (event: NotificationEvent) => {
  event.notification.close();

  const data = event.notification.data as NotificationData | undefined;
  const action = data?.action ?? 'navigate_to_game';
  const gameId = data?.game_id;

  let url = '/';

  if (gameId) {
    switch (action) {
      case 'navigate_to_game':
        url = `/game/${gameId}`;
        break;
      case 'navigate_to_game_over':
        url = `/game-over/${gameId}`;
        break;
      case 'navigate_to_lobby':
        url = `/lobby/${gameId}`;
        break;
      case 'navigate_to_waiting_room':
        url = `/waiting-room/${gameId}`;
        break;
      default:
        url = `/game/${gameId}`;
    }
  }

  event.waitUntil(
    self.clients
      .matchAll({ type: 'window', includeUncontrolled: true })
      .then((clientList) => {
        // Check if there's already a window open
        for (const client of clientList) {
          if (
            client.url === new URL(url, self.location.origin).href &&
            'focus' in client
          ) {
            return client.focus();
          }
        }
        // If no window is open, open a new one
        if (self.clients.openWindow) {
          return self.clients.openWindow(url);
        }
      }),
  );
});
